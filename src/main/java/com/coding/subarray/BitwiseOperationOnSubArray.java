package com.coding.subarray;

/*
    https://www.geeksforgeeks.org/bitwise-operations-on-subarrays-of-size-k/

    Given an array arr[] of positive integers and a number K, the task is to find the minimum and maximum values of Bitwise operation on elements of subarray of size K.

Examples:


    Input: arr[]={2, 5, 3, 6, 11, 13}, k = 3
    Output:
    Maximum AND = 2
    Minimum AND = 0
    Maximum OR = 15
    Minimum OR = 7
    Explanation:
    Maximum AND is generated by subarray 3, 6 and 11, 3 & 6 & 11 = 2
    Minimum AND is generated by subarray 2, 3 and 5, 2 & 3 & 5 = 0
    Maximum OR is generated by subarray 2, 6 and 13, 2 | 6 | 13 = 15
    Minimum OR is generated by subarray 2, 3 and 5, 2 | 3 | 5 = 7

    Input: arr[]={5, 9, 7, 19}, k = 2
    Output:
    Maximum AND = 3
    Minimum AND = 1
    Maximum OR = 23
    Minimum OR = 13

    We will use sliding window technique here to find all, we just need to maintain, when the bit is getting set and getting unset.
    // This can be done by maintaining an array of bits, and just increase or decrease the bit count in the array if current number is getting
    added or removed.

 */

public class BitwiseOperationOnSubArray {

    void add(int [] bit, int a){
        int index = 0;
        while ( a > 0 ){
            if ( (a&1) > 0 ){
                bit[index]++;
            }
            index++;
            a >>= 1;
        }
    }

    void remove(int [] bit, int a){
        int index = 0;
        while ( a > 0 ){
            if ( (a&1) > 0 ){
                bit[index]--;
            }
            index++;
            a >>= 1;
        }
    }

    int or(int [] bit){
        int ans = 0;
        for ( int i = bit.length - 1; i >= 0 ; i--){
            if (bit[i] > 0 ){
                ans <<= 1;
                ans |= 1;
            }
        }
        return ans;
    }


    int minOr(int [] arr, int k){

        int n = arr.length;
        int max_num = 0;
        for ( int i = 0 ; i < n ; i++ ){
            max_num = Math.max(max_num, arr[i]);
        }
        int bit_count = 0;
        while ( max_num > 0 ){
            bit_count++;
            max_num >>= 1;
        }

        int [] bit = new int[bit_count+1]; // Here we have kept it as or, So considered only the contribution of set bit.
        // in case of and, we have to consider the count of zero, because any one zero would make all the bit zero in the range
        int i = 0;
        int j = 0;
        for (i = 0 ; i < k ; i++ ){
            add(bit, arr[i]);
        }
        int ans = or(bit);

        for ( ; i < n ; i++, j++){
            remove(bit, arr[j]);
            add(bit, arr[i]);
            ans = Math.min(ans, or(bit));
        }
        return ans;
    }

    public static void main(String[] args) {
        {
            BitwiseOperationOnSubArray op = new BitwiseOperationOnSubArray();
            int [] arr = new int[]{2, 5, 3, 6, 11, 13};
            int k = 3;
            System.out.println(op.minOr(arr, k));
        }
    }
}
